package source.ErrorModels;

import java.util.Random;

/**
 * Created by bnjhope on 20/10/16.
 */
public class BurstErrorModel implements ITransmissionError {

    /**
     * The generator of the random numbers.
     */
    private Random randomGen;

    /**
     * The current state of the error model. If it is true, then it is in a good state.
     * If it is false, then it is in a bad state, where a bit will be flipped.
     */
    private boolean goodState = true;

    /**
     * The probability that the burst model will go from a good state to a bad state
     */
    private double pOfGoodToBad;

    /**
     * The probability that the burst model will go from a bad state to a good state
     */
    private double pOfBadToGood;

    /**
     * The probability for when the burst model is in its bad state that a bit will be flipped.
     */
    private double pOfError;


    public BurstErrorModel(double pOfError,double pOfGoodToBad, double pOfBadToGood) {
        this.pOfError = pOfError;
        this.pOfGoodToBad = pOfGoodToBad;
        this.pOfBadToGood = pOfBadToGood;

        //makes a new instance of a random number generator for the random number
        //generator of this model
        this.randomGen = new Random();
    }

    /**
     * Determines whether or not a bit should be flipped depending on the current state
     * of the model and the probabilities of errors occuring in the bad state.
     * @return True if a bit should be flipped, false if not.
     */
    public boolean flip() {
        //the result to be returned
        boolean result = false;

        //values generated by the random number generator that are used to check
        //if there is an error or a state change by assigning them random values and
        //checking if they lie below the probabilities defined in the model.
        double errVal, stateVal = this.randomGen.nextDouble();

        //if the current state is good then there is no way an error can occur and
        //so we can assume that no flip needs to be done.
        //Otherwise, if we are in the bad state, then we need to check to see
        //if the random double we generate is going to be within the error probability.
        if(!this.goodState) {

            //assign error value to a random double
            errVal = this.randomGen.nextDouble();

            //if the value of errval lies below the probability of an error in the bad state
            //defined by the model then flip the bit
            if(errVal <= this.pOfError)
                result = true;

            //if the random double assigned to the state change value is less than
            //the probability for a transition between the bad state to the good state
            //then
            if(stateVal <= this.pOfBadToGood)
                this.goodState = true;

        } else {

            //if the random double assigned to the state change value is less than
            //the probability
            if(stateVal <= this.pOfGoodToBad)
                this.goodState = false;
        }
        return result;
    }
}
